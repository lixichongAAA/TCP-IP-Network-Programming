# ch11 进程间通信

## 1. 进程间通信的基本概念

进程间通信(Inter Process Communication，IPC)意味着两个不同进程间可以交换数据，为了完成这一点，操作系统应该提供两个进程可以同时访问的内存空间。

### *1. 对进程间通信的基本理解*

进程A和B之间的如下谈话内容就是一种进程间通信规则。

“如果我有1个面包，变量 *bread* 的值就变为1。如果吃掉这个面包，*bread* 的值又变为0；因此，你可以通过变量 *bread* 的值判断我的状态。”

也就是说，进程A通过变量 *bread* 将自己的状态通知给了进程B，进程B通过变量 *bread* 听到了进程A的话。因此，只要有两个进程可以同时访问的内存空间，就可以通过此内存空间交换数据。但正如第10章所讲，进程具有完全独立的内存结构。就连通过 `fork` 函数创建的子进程也不会与父进程共享内存空间。因此，进程间通信只能通过其他特殊方法完成。

### *2. 通过管道实现进程间通信*

下图表示基于管道的进程间通信模型。

![pipe](./pipe.png "基于管道的进程间通信模型")

从上图中可以看到，为了完成进程间通信，需要创建管道。管道并非属于进程的资源，而是和套接字一样，属于操作系统。所以两个进程通过操作系统提供的内存空间进行通信。下面介绍创建管道的函数。

```c
#include <unistd.h>
int pipe(int filedes[2]);
// 成功时返回0，失败时返回-1
```

- *filedes[0]* ：通过管道接收数据时使用的文件描述符，即管道出口；
- *filedes[1]* ：通过管道传输数据时使用的文件描述符，即管道入口。

*来个例子：*

[pipe1.c](./pipe1.c)

```bash
lxc@Lxc:~/C/tcpip_src/ch11-进程间通信$ bin/pipe1 
Who are you?
```

该示例中的通信方法及路径如下图所示。

![pipe](./pipe1.png "示例pipe1.c的通信路径")

### *3. 通过管道进行进程间的双向通信*

下面创建2个进程通过1个管道进行双向数据交换，其通信方式如下图所示：

![pipe](./pipe2.png "双向通信模型1")

[pipe2.c](./pipe2.c)

注意第19行的 `sleep` 函数调用。***向管道传递数据时，先读的进程会把数据取走***。简言之，数据进入管道后成为无主数据。也就是通过 `read` 函数先读取数据的进程将得到数据，即使是该进程将数据传到了管道。所以，注释第19行将产生问题，在下一行，子进程将读回自己向管道中发送到数据。结果，父进程调用 `read` 后将无限期等待数据进入管道。  

从上述示例可以看到，只用1个管道进行双向通信并非易事。为了实现这一点，程序需要预测并控制运行流程，这在每种系统中都不同，可以视为不可能完成的任务。那可咋办呢？  
非常简单，1个管道无法完成双向通信的任务，那创建2个管道，各自负责不同的数据流动即可。如下图所示。

![pipe](./pipe3.png "双向通信模型2")

[pipe3.c](./pipe3.c)

## 2. 运用进程间通信

### *1. 保存消息的回声服务器端*

下面扩展第10章的 *echo_mpserv.c*，添加如下功能：将回声客户端传输的字符串按序保存到文件中。

[echo_storeserv.c](./echo_storeserv.c)。该示例可与任意回声客户端配合运行，我们用第10章的 [*echo_mpclient.c*](./echo_mpclient.c) 。