# ch15 套接字和标准I/O

我们之前采用的都是默认数据通信手段 `read` & `write` 函数及各种系统I/O函数，你可能想用用学C时掌握的标准I/O函数。

## 1. 标准I/O函数的优点

### *1. 标准I/O函数的两个优点*

- 标准I/O函数具有良好的移植性（Protability）。
- 标准I/O函数可以利用缓冲提高性能。

关于移植性无需多言。关于第二个优点，使用标准I/O函数时会得到额外的缓冲支持。创建套接字时，操作系统将生成用于I/O的缓冲。此缓冲在执行TCP协议时发挥着非常重要的作用。此时若使用标准I/O函数，将得到额外的另一缓冲支持，如图15-1所示。

![15](./15-1.png "缓冲的关系")

从图15-1中可以看到，使用标准I/O函数传输数据时，经过2个缓冲。例如，通过 `fputs` 函数传输字符串 "Hello" 时，首先将数据传递到标准I/O函数的缓冲。然后将数据移动到套接字输出缓冲中，最后将数据发送到对方主机。

既然知道了两个缓冲的关系，接下来再说明各自的用途，设置缓冲的目的主要是为了提高性能，但套接字中的缓冲主要是为了实现TCP协议而设立的。例如，TCP传输中丢失数据时将再次传递，而再次发送数据意味着在某地保存了数据，存在什么地方呢？套接字的输出缓冲。与之相反，使用标准I/O缓冲的主要目的是为了提高性能。

"使用缓冲可以大大提高性能吗？"

实际上缓冲并非在所有情况下都能带来卓越的性能。但需要传输的数据越多，有无缓冲带来的性能差异越大。可以通过如下两种角度说明性能的提高。

- 传输的数据量
- 数据向输出缓冲移动的次数

比较1个字节发送10次（10个数据包）的情况和累计10个字节发送1次的情况。发送数据时使用的数据包含有头信息。头信息与数据大小无关，是按照一定格式填入的。即使假设该头信息占用40字节，需要传递的数据量也存在较大差别。

- 1个字节 10次： 40 * 10 = 400字节
- 10个字节 1次： 40 * 1 = 40字节

所以，在有缓冲的情况下，我们可以缓冲较多数据，减少发送次数，减少了传递的数据量。  
另外，为了发送数据，向套接字输出缓冲移动数据也会消耗不少时间。但这同样与移动次数有关。1个字节数据移动10次花费的时间将近10个字节数据移动1次花费时间的10倍。

### *2. 标准I/O函数和系统函数之间的性能对比*

[syscpy.c](./syscpy.c) [stdcpy.c](./stdcpy.c)

复制对象仅限于文本文件，最好是300M以上的，可以看出标准I/O函数明显快于系统I/O函数。

### *3. 标准I/O函数的几个缺点*

- 不易进行双向通信
- 有时可能频繁调用 `fflush` 函数
- 需要以FILE结构体指针的形式返回文件描述符

打开文件时，如果希望同时进行读写操作，则应以r+、w+、a+模式打开。但因为缓冲的缘故，每次切换工作状态时应调用 `fflush` 函数。这也会影响基于缓冲的性能提高。而且，为了使用标准I/O函数，需要FILE结构体指针。而创建套接字时默认返回文件描述符，因此需要将文件描述符转化为FILE指针。

## 2. 使用标准I/O函数

如前所述，创建套接字时返回文件描述符，而为了使用标准I/O函数，只能将其转换为FILE结构体指针。先介绍其转换方法。

### *1. 利用 `fdopen` 函数转换为 FILE 结构体指针*

```c
SYNOPSIS
#include <stdio.h>
          FILE *fdopen(int fd, const char *mode);
// 成功时返回转换的FILE结构体指针，失败时返回NULL。
```

- *fd* ：需要转换的文件描述符。
- *mode* ：将要创建的FILE结构体指针的模式信息，与 `fopen` 函数中的打开模式相同，常见的 读模式 "r"，写模式 "w"。

[desto.c](./desto.c)

```bash
lxc@Lxc:~/C/tcpip_src/ch15-套接字和标准IO$ bin/desto 
lxc@Lxc:~/C/tcpip_src/ch15-套接字和标准IO$ cat data.dat 
I Like ....
```

### *2. 利用 `fileno` 函数转换为文件描述符*

```c
SYNOPSIS
       #include <stdio.h>
       int fileno(FILE *stream);
// 成功时返回转换后的文件描述符，失败时返回-1。
```

[todes.c](./todes.c)

```bash
lxc@Lxc:~/C/tcpip_src/ch15-套接字和标准IO$ bin/todes 
First file descriptor: 3
Second file descriptor: 3
```

## 3. 基于套接字的标准I/O函数使用

[echo_stdserv.c](./echo_stdserv.c)
[echo_stdclnt.c](./echo_stdclnt.c)

第4章的回声客户端需要将接收的数据转换为字符串（数据的尾部插入0），但本章的回声客户端没有这一过程。因为，使用标准I/O函数后可以以字符串为单位进行数据交换。